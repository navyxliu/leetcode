#include <vector>
#include <iostream>
using namespace std;

#define INF ((1<<31) - 1)
#define CAP(x) (x==INF ? INF : x+1)


#define INF ((1<<31) - 1)
#define CAP(x) (x==INF ? INF : x+1)
struct Point {
    int x, y, d;
    int pos; 
    vector<Point*> adj; 

    Point(int i, int j, int dist=INF) : x(i), y(j), d(dist) {}
    Point() : d(INF) {}
    void addEdge(Point * t) {
      adj.push_back(t); 
    }
};

//min-heap priority Q
template <class T> 
class PrioQueue {
  vector<T*> arr; 

public:
  void push(T* e) {
    arr.push_back(e);
    e->pos = arr.size()-1; 
    siftUp(arr.size()-1);
  }  

  T* pop() {
    T* t = arr[0];
    arr[0] = arr.back();
    arr.pop_back();
    arr[0]->pos = 0;
    siftDown(0);

    t->pos = -1;
    return t; 
  }

  bool empty() {
    return arr.size() == 0;
  }

  int index(const T * e) {
    return e->pos;
  }

  void siftUp(int i) {
    while (i > 0) {
      int p = i/2; 
      if (arr[p]->d <= arr[i]->d) break;

      swap(arr[p], arr[i]);
      arr[p]->pos = i; 
      arr[i]->pos = p;
      i = p;
    } 
  }

  void siftDown(int i) {
    int sz = arr.size(); 

    while (i*2+1 < sz) {
      int k = i * 2 + 1;
      if (k < sz-1 && arr[k+1]->d < arr[k]->d) k++;
      if (arr[i] <= arr[k]) break;

      swap(arr[i], arr[k]);
      arr[k]->pos = i;
      arr[i]->pos = k;

      i = k; 
    }
    
  }  
};

class Solution {
   
    int m, n; 
public:
    void wallsAndGates(vector<vector<int>>& rooms) {
      m = rooms.size(); 
      if (m <= 0) return;
      n = rooms[0].size();
      
       
      vector<vector<Point>> G(m, vector<Point>(n)); 
      PrioQueue<Point> Q; 

      for (int i=0; i<m; ++i) for (int j=0; j<n; ++j) {
        if (rooms[i][j] == INF) {
          Point & t = G[i][j] = Point(i, j, check(i, j, rooms));
          Q.push(&G[i][j]);

          if (i > 0 && rooms[i-1][j] == INF) t.addEdge(&G[i-1][j]);
          if (j > 0 && rooms[i][j-1] == INF) t.addEdge(&G[i][j-1]);
          if (i < m-1 && rooms[i+1][j] == INF) t.addEdge(&G[i+1][j]);
          if (j < n-1 && rooms[i][j+1] == INF) t.addEdge(&G[i][j+1]);
        }
      } 
      
      while (!Q.empty()) {
          Point * pt = Q.pop();
            
          if (pt->d == INF) 
            break;
          
          rooms[pt->x][pt->y] = pt->d; 
          for (auto t : pt->adj) {
            int idx = t->pos;
            if (idx != -1) {
              Q.siftUp(idx);
            }
          } 
      }
    }

    int check(int x, int y, vector<vector<int>>& rooms) {
        int d = INF; 
        
        if (x > 0 && rooms[x-1][y] != INF && rooms[x-1][y] != -1)
            d = min(d, rooms[x-1][y]+1);
        if (y > 0 && rooms[x][y-1] != INF && rooms[x][y-1] != -1)
            d = min(d, rooms[x][y-1]+1);
        if (x < m-1 && rooms[x+1][y] != INF && rooms[x+1][y] != -1)
            d = min(d, rooms[x+1][y]+1);
        if (y < n-1 && rooms[x][y+1] != INF && rooms[x][y+1] != -1)
            d = min(d, rooms[x][y+1]+1);
            
        return d; 
    }
};

int main() {
  Solution sol; 
  vector<vector<int>> rooms; 

  rooms.push_back({2147483647,2147483647,-1,2147483647,-1,-1,2147483647,0,0,0,0,-1,2147483647,-1,2147483647,2147483647,0,-1,-1,2147483647,2147483647,0,-1,0,-1,2147483647,2147483647,0,0,2147483647,-1,2147483647,-1,2147483647,-1,2147483647,-1,0,-1,-1,2147483647,0,2147483647,0,2147483647,2147483647,2147483647,0,0,0,-1,-1,-1,2147483647,2147483647,-1,2147483647,2147483647,-1,-1,-1,2147483647,0,-1,-1,2147483647,2147483647,2147483647,2147483647,-1,2147483647,-1,0,-1,-1,-1,2147483647,-1,0,0,2147483647,2147483647,-1,-1,2147483647,0,2147483647,-1,0,-1,-1,0,2147483647,2147483647,0,-1,0,2147483647,0,2147483647,0,-1,-1,0,-1,-1,0,2147483647,0,2147483647,-1,0,0,0,0,2147483647,2147483647,2147483647,-1,-1,2147483647,-1,2147483647,-1,0,-1,-1,-1,2147483647,0,0,0,0,-1,2147483647,0,0,2147483647,0,0,2147483647,2147483647,-1,2147483647,-1,0,-1,2147483647,0,2147483647,0,0,0,-1,0,0,2147483647,-1,2147483647,-1,0,0,0,2147483647,2147483647,2147483647,2147483647,0,0,2147483647,0,2147483647,2147483647,0,2147483647,-1,0,-1,2147483647,-1,-1,0,0,2147483647,2147483647,0,-1,-1,-1,0,-1,-1,2147483647,0,-1,2147483647,0,0,2147483647,-1,0,-1,2147483647,-1,-1,-1,2147483647,0,0,0,2147483647,0,0,2147483647,2147483647,-1,2147483647,2147483647,2147483647,-1,0});


rooms.push_back({-1,-1,-1,2147483647,0,-1,-1,2147483647,0,-1,0,0,-1,2147483647,-1,-1,-1,-1,-1,2147483647,-1,-1,2147483647,0,0,-1,-1,0,2147483647,-1,0,2147483647,-1,2147483647,-1,-1,-1,-1,2147483647,2147483647,0,2147483647,0,0,0,-1,-1,0,2147483647,0,0,-1,0,2147483647,-1,2147483647,0,2147483647,-1,2147483647,0,0,-1,0,-1,-1,0,-1,0,2147483647,-1,0,-1,-1,2147483647,2147483647,-1,0,0,-1,0,-1,-1,2147483647,2147483647,-1,0,0,0,0,0,2147483647,-1,-1,2147483647,0,2147483647,0,-1,-1,0,-1,2147483647,0,-1,-1,0,2147483647,2147483647,-1,-1,2147483647,0,0,0,-1,2147483647,-1,0,-1,-1,0,-1,0,0,-1,-1,-1,0,0,0,2147483647,2147483647,2147483647,-1,2147483647,0,0,0,0,2147483647,2147483647,-1,-1,0,2147483647,-1,-1,0,2147483647,-1,2147483647,2147483647,-1,-1,-1,2147483647,2147483647,2147483647,-1,0,2147483647,-1,0,-1,-1,-1,-1,0,-1,2147483647,-1,0,-1,0,-1,2147483647,-1,-1,0,0,-1,2147483647,0,0,0,2147483647,-1,2147483647,-1,0,2147483647,2147483647,2147483647,0,0,-1,-1,0,0,0,2147483647,2147483647,2147483647,2147483647,0,2147483647,2147483647,-1,2147483647,-1,0,0,0,2147483647,-1,2147483647,2147483647,0,-1,-1});
  sol.wallsAndGates(rooms);
 
  for (auto & row: rooms) {
    for (auto & v: row) {
      if (v == INF) cout << "INF ";
      else cout << v << " " ; 
    }
    cout << "\n";
  }
}
